# CNCF × Alibaba 云原生技术公开课

### 第一堂“云原生”课

* 云原生的定义

  云原生是一条最佳路径或者最佳实践。更详细的说，云原生为用户指定了一条低心智负担的、敏捷的、能够以可扩展、可复制的方式最大化地利用云的能力、发挥云的价值的最佳路径。

  因此，云原生其实是一套指导进行软件架构设计的思想。按照这样的思想而设计出来的软件：首先，天然就“生在云上，长在云上”；其次，能够最大化地发挥云的能力，使得我们开发的软件和“云”能够天然地集成在一起，发挥出“云”的最大价值。

  所以，云原生的最大价值和愿景，就是认为未来的软件，会从诞生起就生长在云上，并且遵循一种新的软件开发、发布和运维模式，从而使得软件能够最大化地发挥云的能力。

* 为什么容器技术具有革命性

  容器技术和集装箱技术的革命性非常类似，即：容器技术使得应用具有了一种“自包含”的定义方式。所以，这样的应用才能以敏捷的、以可扩展、可复制的方式发布在云上，发挥出云的能力。这也就是容器技术对云发挥出的革命性影响所在，所以说，容器技术正是云原生技术的核心底盘。

* 云原生的技术范畴

  * 云应用定义与开发流程

    这包括应用定义与镜像制作、配置 CI/CD、消息和 Streaming 以及数据库等。

  * 云应用的编排与管理流程

    包括了应用编排与调度、服务发现与治理、远程调用、API 网关以及 Service Mesh。

  * 监控与可观测性

    这部分所强调的是云上应用如何进行监控、日志收集、Tracing 以及在云上如何实现破坏性测试，也就是混沌工程的概念。

  * 云原生的底层技术

    比如容器运行时、云原生存储技术、云原生网络技术等。

  * 云原生工具集

    在前面的这些核心技术点之上，还有很多配套的生态或者周边的工具需要使用，比如流程自动化与配置管理、容器镜像仓库、云原生安全技术以及云端密码管理等。

  * Serverless

    Serverless 是一种 PaaS 的特殊形态，它定义了一种更为“极端抽象”的应用编写方式，包含了 FaaS 和 BaaS 这样的概念。而无论是 FaaS 还是 BaaS，其最为典型的特点就是按实际使用计费（Pay as you go），因此 Serverless 计费也是重要的知识和概念。

* 云原生思想的两个理论基础

  * 不可变基础设施

    这一点目前是通过容器镜像来实现的，其含义就是应用的基础设施应该是不可变的，是一个自包含、自描述可以完全在不同环境中迁移的东西。

  * 云应用编排理论

    当前的实现方式就是 Google 所提出来的“容器设计模式”。

* 基础设施向云演进的过程

  一旦应用部署完成之后，那么这套应用基础设施就不会再修改了。如果需要更新，那么需要更改公共镜像来构建新服务直接替换旧服务。而我们之所以能够实现直接替换，就是因为容器提供了自包含的环境（包含应用运行所需的所有依赖）。

* 基础设施向云演进的意义

  * 基础设施一致性和可靠性

    容器镜像、自包含、可漂移

  * 简单可预测的部署和运维

    自描述，自运维、流程自动化、容易水平扩展、可快速复制的管控系统与支撑组件

* 云原生关键技术点

  * 如何构建自包含、可定制的应用镜像
  * 能不能实现应用快速部署与隔离能力
  * 应用基础设施创建和销毁的自动化管理
  * 可复制的管控系统和支撑组件

* 总结

  “未来的软件一定是生长于云上的”这是云原生理念的最核心假设。而所谓“云原生”，实际上就是在定义一条能够让应用最大程度利用云的能力、发挥云的价值的最佳路径。在这条路径上，脱离了“应用”这个载体，“云原生”就无从谈起；容器技术，则是将这个理念落地、将软件交付的革命持续进行下去的重要手段之一。

### 容器基本概念

* 容器与镜像

  * 操作系统管理的进程

    * 进程可见、可相互通信

      高级权限的进程可以攻击其他进程。

    * 共享同一份文件系统

      这些进程可以对于已有的数据进行增删改查，具有高级权限的进程可能会将其他进程的数据删除掉，破坏掉其他进程的正常运行。此外，进程与进程之间的依赖可能会存在冲突。

    * 使用相同的系统资源

      因为这些进程使用的是同一个宿主机的资源，应用之间可能会存在资源抢占的问题，当一个应用需要消耗大量 CPU 和内存资源的时候，可能会破坏其他应用的运行，导致其他应用无法正常地提供服务。

  * 如何为进程提供一个独立的运行环境

    * 资源视图隔离 namespace
    * 独立的文件系统 chroot
    * 控制资源使用率 cgroup

  * 什么是容器

    容器是一个视图隔离、资源可限制、独立文件系统的进程集合。

  * 什么是镜像

    运行容器所需要的所有文件集合。

    通常情况下，我们会采用 Dockerfile 来构建镜像，这是因为 Dockerfile 提供了非常便利的语法糖，能够帮助我们很好地描述构建的每个步骤。当然，每个构建步骤都会对已有的文件系统进行操作，这样就会带来文件系统内容的变化，我们将这些变化称之为 changeset。当我们把构建步骤所产生的变化依次作用到一个空文件夹上，就能够得到一个完整的镜像。

    changeset 具有分层及复用的特点。

  * 如何构建镜像

    Dockerfile - FROM / WORKDIR / COPY / RUN / CMD

    docker build / docker push（docker registry）

  * 如何运行容器

    docker pull / docker images / docker run

* 容器生命周期

  * 单进程模型

    init 进程生命周期 = 容器生命周期

    运行期间可运行 exec 执行运维操作

  * 数据持久化

    独立于容器的生命周期

    数据卷 - docker volume vs bind

* 容器项目的架构

  * moby 容器引擎架构

    * moby daemon

      会对上提供有关于容器、镜像、网络以及 volume 的管理。

    * containerd

      容器运行时管理引擎，独立于 moby daemon ，可以对上提供容器、镜像的相关管理。

    * shim

      其类似于一个守护进程。

      containerd 需要管理容器生命周期，而容器可能是由不同的容器运行时所创建出来的（runC / kata / gVisor），因此需要提供一个灵活的插件化管理。而 shim 就是针对于不同的容器运行时所开发的，这样就能够从 containerd 中脱离出来，通过插件的形式进行管理。

      因为 shim 插件化的实现，使其能够被 containerd 动态接管。如果不具备这样的能力，当 moby daemon 或者 containerd daemon 意外退出的时候，容器就没人管理了，那么它也会随之消失、退出，这样就会影响到应用的运行。

      因为随时可能会对 moby 或者 containerd 进行升级，如果不提供 shim 机制，那么就无法做到原地升级，也无法做到不影响业务的升级，因此 shim 非常重要，它实现了动态接管的能力。

* 容器 vs VM

  VM 利用 Hypervisor 虚拟化技术来模拟 CPU、内存等硬件资源，这样就可以在宿主机上建立一个 Guest OS，这是常说的安装一个虚拟机。

  每一个 Guest OS 都有一个独立的内核，比如 Ubuntu、CentOS 甚至是 Windows 等，在这样的 Guest OS 之下，每个应用都是相互独立的，VM 可以提供一个更好的隔离效果。但这样的隔离效果需要付出一定的代价，因为需要把一部分的计算资源交给虚拟化，这样就很难充分利用现有的计算资源，并且每个 Guest OS 都需要占用大量的磁盘空间，比如 Windows 操作系统的安装需要 10~30G 的磁盘空间，Ubuntu 也需要 5~6G，同时这样的方式启动很慢。

  容器是针对于进程而言的，因此无需 Guest OS，只需要一个独立的文件系统提供其所需要文件集合即可。所有的文件隔离都是进程级别的，因此启动时间快于 VM，并且所需的磁盘空间也小于 VM。当然了，进程级别的隔离并没有想象中的那么好，隔离效果相比 VM 要差很多。